import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import edu.princeton.cs.algs4.MinPQ;
class TempBoard implements Comparable{
	Board board;
	int priority;
	
	public int compareTo(TempBoard) {
        return (this.board.manhattan() - move.board.manhattan()) + (this.numMoves - move.numMoves);
    }
	
}


public class Solver {

    // find a solution to the initial board (using the A* algorithm)
	private MinPQ<Board> queue = new MinPQ<Board>();
	private int moves = 0;
	private List<Board> solutionList;
    public Solver(Board initial)
    {
    	Board currentBoard = initial;
    	if(initial.manhattan()==0)
		{
    		solutionList.add(currentBoard);
			return;
		}
    	queue.insert(currentBoard);
    	List<Board> value = new ArrayList<Board>();
    	value.add(currentBoard);
    	moves=0;
    	solutionList = new ArrayList<>();
    	while(!queue.isEmpty())
    	{
    		moves++;
    		currentBoard = queue.min();
    		solutionList.add(currentBoard);
    		//System.out.println(currentBoard.toString());
    		if(currentBoard.manhattan()==0)
    		{
    			solutionList.add(currentBoard);
    			return;
    		}
	    	Iterator<Board> test = currentBoard.neighbors().iterator();
	    	while(test.hasNext())
	    	{
	    		Board tempBoard = test.next();
	    		int manhattan = tempBoard.manhattan();
	    		if(manhattan==0)
	    		{
	    			solutionList.add(tempBoard);
	    			return;
	    		}
	    		int priority = manhattan+moves;
	    		queue.insert(tempBoard);
	    	}
    	}
    }

	private Board removeList(int highest) {
		Board currentBoard;
		List<Board> currentList = map.get(highest);
		if(currentList.size()>1)
		{
			currentBoard = currentList.get(0);
			currentList.remove(0);
			map.put(highest, currentList);
		}
		else {
			currentBoard = currentList.get(0);
			queue.delMin();
			map.remove(highest);
		}
		return currentBoard;
	}

    // is the initial board solvable? (see below)
    public boolean isSolvable()
    {
    	return false;
    }

    // min number of moves to solve initial board
    public int moves()
    {
    	return moves;
    }

    // sequence of boards in a shortest solution
    public Iterable<Board> solution() {
    	return new BoardIterable();
    }
    
    private class BoardIterable implements Iterable<Board> { 
        
        // code for data structure 
        public Iterator<Board> iterator() { 
            return new BoardIterator(); 
        } 
    } 
    
    private class BoardIterator implements Iterator<Board>
    {
    	private int count = 0;
    	private List<Board> resultList;
    	BoardIterator()
    	{
    		resultList = solutionList;
    	}
	    public boolean hasNext() {
	    	if(count<resultList.size())
    			return true;
    		else
    			return false;
    	}
    	public void remove() {
    		throw new UnsupportedOperationException();
    	}
    	public Board next() {
    		Board tempBoard = resultList.get(count);
    		count++;
    		return tempBoard;
    	}	
    }


    // test client (see below) 
    public static void main(String[] args)
    {
    	int[][] temp = {{0,1,3},{4,2,5},{7,8,6}};
    	int[][] temp1 = {{0,1,3},{4,2,5},{7,8,6}};
    	Board board = new Board(temp);
    	Solver solver = new Solver(board);
    	Iterator<Board> test = solver.solution().iterator();
    	System.out.println("the count is "+solver.moves());
    	while(test.hasNext())
    	{
    		System.out.println(test.next().toString());
    	}
    }

}