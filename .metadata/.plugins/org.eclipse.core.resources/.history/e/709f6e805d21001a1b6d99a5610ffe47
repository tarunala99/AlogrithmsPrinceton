import edu.princeton.cs.algs4.StdRandom;

public class Percolation {

	private int[] precolationMatrix;
	
	private int[] getPrecolationMatrix() {
		return precolationMatrix;
	}

	private void setPrecolationMatrix(int[] precolationMatrix) {
		this.precolationMatrix = precolationMatrix;
	}

	private int getSize() {
		return size;
	}

	private void setSize(int size) {
		this.size = size;
	}

	private int getOpenCount() {
		return openCount;
	}

	private void setOpenCount(int openCount) {
		this.openCount = openCount;
	}

	private int size;
	
	private int openCount;
    // creates n-by-n grid, with all sites initially blocked
    public Percolation(int n)
    {
    	precolationMatrix = new int[n*n];
    	size = n;
    	for(int i=0;i<n;i++)
    	{
    		for(int j=0;j<n;j++)
        	{
    			precolationMatrix[j+n*i]=-100;
        	}
    	}
    }

    // opens the site (row, col) if it is not open already
    public void open(int row, int col)
    {
    	//implement the is full logic here
    	if(!isOpen(row,col))
    	{
    			boolean flag = false;
    			//the upper one
    			if(row-1>=0 && precolationMatrix[col+size*(row-1)]!=-100)
    			{
    				precolationMatrix[col+size*row]=col+size*(row-1);
    				flag = true;
    			}
    			//left side
    			if(col-1>=0 && precolationMatrix[(col-1)+size*(row)]!=-100)
    			{
    				precolationMatrix[col+size*row]=(col-1)+size*(row);
    				flag = true;
    			}
    			//the one below
    			if((row+1<size && precolationMatrix[col+size*(row+1)]!=-100))
    			{
    				precolationMatrix[col+size*(row+1)]=col+size*row;
    			}
    			//the right side
    			if(	(col+1<size && precolationMatrix[(col+1)+size*(row)]!=-100))
    			{
    				precolationMatrix[(col+1)+size*(row)]=col+size*row;
    			}
    			if(!flag)
    			{
    				precolationMatrix[col+size*row]=col+size*row;
    			}
    			if(row==0)
        		{
        			precolationMatrix[col+size*row]=-200;
        		}
        		
    		openCount++;
    	}
    	//only open when it is not closed
    	else
    	{
    		return;
    	}
    	
    	//check for connection
    }

    // is the site (row, col) open?
    public boolean isOpen(int row, int col)
    {
    	int value = precolationMatrix[col+size*row];
    	//could have parent value or the column value
    	if(value != -100)
    		return true;
    	else
    		return false;
    }

    // is the site (row, col) full?
    public boolean isFull(int row, int col)
    {
    	//iterate till the parent
    	int value = precolationMatrix[col+size*row];
    	//iterate as long as they are not equal
    	// and as long as it hasn't reached the root yet
    	while(value>=0 && precolationMatrix[value]>=0 && precolationMatrix[value]!=value)
    	{
    		value = precolationMatrix[value];
    	}
    	
    	if(value>=0 && precolationMatrix[value]==-200)
    		return true;
    	else
    		return false;
    }

    // returns the number of open sites
    public int numberOfOpenSites()
    {
    	return openCount;
    }

    // does the system percolate?
    public boolean percolates()
    {
    	for(int i=0;i<size;i++)
    	{
    		if(precolationMatrix[i+size*(size-1)]!=-200 && isFull(size-1,i))
    			return true;
    	}
    	return false;
    }
    
    // test client (optional)
    public static void main(String[] args)
    {
    	Percolation percolation = new Percolation(200);
    	int[] tempArray = percolation.getPrecolationMatrix();
    	int count = 0;
    	int temp = (int)Math.random();
    	int[] tempArray1 = {10,20,30,40,50,60,0,80,67,98,23,1,90,70,34,23,33};
    	int count2=0;
    	while(!percolation.percolates())
    	{
    		
    		int index = StdRandom.uniform(0, 200*200);
    		//int index = tempArray1[count2];
    		count2++;
        	int row = index/percolation.getSize();
        	int col =  index%percolation.getSize();
        	
    		if(!percolation.isOpen(row,col))
    		{
    			count++;
    			//System.out.println(index);
    			//System.out.println(Arrays.toString(percolation.getPrecolationMatrix()));
    			percolation.open(row,col);
    		}
    		temp=index;
    	}
    	
    	System.out.println("The final count is "+count);
    	
    	
    }
}